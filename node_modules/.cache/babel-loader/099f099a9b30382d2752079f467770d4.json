{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nconst astar = (grid, startNode, endNode, heuristic, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let diagDist = 1.414;\n  if (heuristic === \"chebyshev\") diagDist = 1;\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      //Tie-breaker\n      if (a.f === b.f) return a.h - b.h;\n      return a.f - b.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity; //h : heuristic\n\n      node.h = Infinity; //f = g + h\n\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].h = 0;\n  grid[startNode.row][startNode.column].f = 0;\n  pq.queue(grid[startNode.row][startNode.column]);\n\n  while (pq.length) {\n    const node = pq.dequeue();\n    const {\n      row,\n      col\n    } = node;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n\n    if (node.row === endNode.row && node.col === endNode.column) {\n      shortestPath = getShortestPath(node);\n      break;\n    }\n\n    const n = [[1, 0], [0, 1], [-1, 0], [0, -1]]; //with diag\n\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n\n      if (grid[r] && grid[r][c] && !grid[r][c].isVisited && (!grid[r][c].isWall || r === endNode.row && c === endNode.column)) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return {\n            visitedNodes,\n            shortestPath\n          };\n        }\n\n        const dist = Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? diagDist : 1;\n        let gNew = grid[row][col].g + dist;\n        let hNew = calculateHeuristic(r, c, endNode, heuristic, diagDist);\n        let fNew = gNew + hNew;\n\n        if (grid[r][c].f > fNew) {\n          grid[r][c].g = gNew;\n          grid[r][c].h = hNew;\n          grid[r][c].f = fNew;\n          grid[r][c].prevNode = node;\n          pq.queue(grid[r][c]);\n        }\n      }\n    }\n  }\n\n  return {\n    visitedNodes,\n    shortestPath\n  };\n};\n\nconst calculateHeuristic = (row, col, endNode, heuristic, diagDist) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans;\n\n  if (heuristic === \"manhatten\") {\n    ans = d * (dx + dy);\n  }\n\n  if (heuristic === \"euclidean\") {\n    ans = d * Math.sqrt(dx * dx + dy * dy);\n  }\n\n  if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n    let d2 = diagDist;\n    ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n  }\n\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n\n  return shortestPath;\n};\n\nexport default astar;","map":{"version":3,"sources":["/home/aakash/Desktop/PathfindingVis-master/src/algorithms/astar.js"],"names":["PriorityQueue","astar","grid","startNode","endNode","heuristic","allowDiag","visitedNodes","shortestPath","diagDist","pq","comparator","a","b","f","h","forEach","row","node","g","Infinity","prevNode","column","queue","length","dequeue","col","isVisited","push","getShortestPath","n","j","i","r","c","isWall","dist","Math","abs","gNew","hNew","calculateHeuristic","fNew","dx","dy","d","ans","sqrt","d2","max","min","unshift","isShortestPath"],"mappings":"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","sourcesContent":["import PriorityQueue from \"js-priority-queue\";\n\nconst astar = (grid, startNode, endNode, heuristic, allowDiag) => {\n  let visitedNodes = [];\n  let shortestPath = [];\n  let diagDist = 1.414;\n  if (heuristic === \"chebyshev\") diagDist = 1;\n  let pq = new PriorityQueue({\n    comparator: function(a, b) {\n      //Tie-breaker\n      if (a.f === b.f) return a.h - b.h;\n      return a.f - b.f;\n    }\n  });\n  grid.forEach(row => {\n    row.forEach(node => {\n      //g : distance\n      node.g = Infinity;\n      //h : heuristic\n      node.h = Infinity;\n      //f = g + h\n      node.f = Infinity;\n      node.prevNode = null;\n    });\n  });\n  grid[startNode.row][startNode.column].g = 0;\n  grid[startNode.row][startNode.column].h = 0;\n  grid[startNode.row][startNode.column].f = 0;\n  pq.queue(grid[startNode.row][startNode.column]);\n  while (pq.length) {\n    const node = pq.dequeue();\n    const { row, col } = node;\n    grid[row][col].isVisited = true;\n    visitedNodes.push(node);\n    if (node.row === endNode.row && node.col === endNode.column) {\n      shortestPath = getShortestPath(node);\n      break;\n    }\n    const n = [\n      [1, 0],\n      [0, 1],\n      [-1, 0],\n      [0, -1]\n    ];\n    //with diag\n    if (allowDiag) n.push([-1, 1], [1, 1], [-1, -1], [1, -1]);\n    for (let j = 0; j < n.length; j++) {\n      const i = n[j];\n      const r = row + i[0];\n      const c = col + i[1];\n      if (\n        grid[r] &&\n        grid[r][c] &&\n        !grid[r][c].isVisited &&\n        (!grid[r][c].isWall || (r === endNode.row && c === endNode.column))\n      ) {\n        if (r === endNode.row && c === endNode.column) {\n          grid[r][c].isVisited = true;\n          grid[r][c].prevNode = grid[row][col];\n          shortestPath = getShortestPath(grid[r][c]);\n          return { visitedNodes, shortestPath };\n        }\n        const dist =\n          Math.abs(i[0]) === 1 && Math.abs(i[1]) === 1 ? diagDist : 1;\n        let gNew = grid[row][col].g + dist;\n        let hNew = calculateHeuristic(r, c, endNode, heuristic, diagDist);\n        let fNew = gNew + hNew;\n        if (grid[r][c].f > fNew) {\n          grid[r][c].g = gNew;\n          grid[r][c].h = hNew;\n          grid[r][c].f = fNew;\n          grid[r][c].prevNode = node;\n          pq.queue(grid[r][c]);\n        }\n      }\n    }\n  }\n  return { visitedNodes, shortestPath };\n};\n\nconst calculateHeuristic = (row, col, endNode, heuristic, diagDist) => {\n  const dx = Math.abs(row - endNode.row);\n  const dy = Math.abs(col - endNode.column);\n  const d = 1;\n  let ans;\n  if (heuristic === \"manhatten\") {\n    ans = d * (dx + dy);\n  }\n  if (heuristic === \"euclidean\") {\n    ans = d * Math.sqrt(dx * dx + dy * dy);\n  }\n  if (heuristic === \"octile\" || heuristic === \"chebyshev\") {\n    let d2 = diagDist;\n    ans = d * Math.max(dx, dy) + (d2 - d) * Math.min(dx, dy);\n  }\n  return ans;\n};\n\nconst getShortestPath = node => {\n  let shortestPath = [];\n  while (node !== null) {\n    shortestPath.unshift(node);\n    node = node.prevNode;\n    if (node) node.isShortestPath = true;\n  }\n  return shortestPath;\n};\n\nexport default astar;\n"]},"metadata":{},"sourceType":"module"}