{"ast":null,"code":"const HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nlet addedWalls = [];\nlet removedWalls = [];\n\nconst recursiveDivision = (grid, rows, columns) => {\n  addedWalls = [];\n  removedWalls = [];\n\n  for (let i = 0; i < rows; i++) {\n    grid[i][0].isWall = true;\n    grid[rows - i - 1][columns - 1].isWall = true;\n    addedWalls.push(grid[i][0]);\n    addedWalls.push(grid[rows - i - 1][columns - 1]);\n  }\n\n  for (let j = 0; j < columns; j++) {\n    grid[0][columns - j - 1].isWall = true;\n    grid[rows - 1][j].isWall = true;\n    addedWalls.push(grid[0][columns - j - 1]);\n    addedWalls.push(grid[rows - 1][j]);\n  }\n\n  const width = columns;\n  const height = rows;\n  divide(grid, 0, 0, width, height, chooseOrientation(width, height));\n  return {\n    addedWalls,\n    removedWalls,\n    animAddedWalls: true\n  };\n};\n\nconst divide = (grid, x, y, width, height, orientation) => {\n  if (height < 2 && width < 2) return;\n  const horizontal = orientation === HORIZONTAL;\n  let wx = x + (horizontal ? randEven(height - 2) : 0);\n  let wy = y + (horizontal ? 0 : randEven(width - 2));\n  const px = wx + (horizontal ? 0 : randOdd(height));\n  const py = wy + (horizontal ? randOdd(width) : 0);\n  const dx = horizontal ? 0 : 1;\n  const dy = horizontal ? 1 : 0;\n\n  do {\n    if (wx !== px || wy !== py) {\n      grid[wx][wy].isWall = true;\n      addedWalls.push(grid[wx][wy]);\n    }\n\n    wx += dx;\n    wy += dy;\n  } while (grid[wx][wy].isWall !== true);\n\n  let nx = x;\n  let ny = y;\n  let w = horizontal ? width : wy - y;\n  let h = horizontal ? wx - x : height;\n  divide(grid, nx, ny, w, h, chooseOrientation(w, h));\n  ny = horizontal ? y : wy;\n  nx = horizontal ? wx : x;\n  w = horizontal ? width : y + width - wy - 1;\n  h = horizontal ? x + height - wx - 1 : height;\n  divide(grid, nx, ny, w, h, chooseOrientation(w, h));\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) return HORIZONTAL;else if (width > height) return VERTICAL;\n  return Math.random() >= 0.5 ? HORIZONTAL : VERTICAL;\n};\n\nconst randEven = i => {\n  return Math.floor(randomNumber(i, 2) / 2) * 2;\n};\n\nconst randOdd = i => {\n  return Math.floor(Math.random() * (i / 2)) * 2 + 1;\n};\n\nconst randomNumber = (max, min) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport default recursiveDivision;","map":{"version":3,"sources":["/home/aakash/Desktop/PathfindingVis-master/src/mazeGen/recursiveDivison.js"],"names":["HORIZONTAL","VERTICAL","addedWalls","removedWalls","recursiveDivision","grid","rows","columns","i","isWall","push","j","width","height","divide","chooseOrientation","animAddedWalls","x","y","orientation","horizontal","wx","randEven","wy","px","randOdd","py","dx","dy","nx","ny","w","h","Math","random","floor","randomNumber","max","min"],"mappings":"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","sourcesContent":["const HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nlet addedWalls = [];\nlet removedWalls = [];\nconst recursiveDivision = (grid, rows, columns) => {\n  addedWalls = [];\n  removedWalls = [];\n  for (let i = 0; i < rows; i++) {\n    grid[i][0].isWall = true;\n    grid[rows - i - 1][columns - 1].isWall = true;\n    addedWalls.push(grid[i][0]);\n    addedWalls.push(grid[rows - i - 1][columns - 1]);\n  }\n  for (let j = 0; j < columns; j++) {\n    grid[0][columns - j - 1].isWall = true;\n    grid[rows - 1][j].isWall = true;\n    addedWalls.push(grid[0][columns - j - 1]);\n    addedWalls.push(grid[rows - 1][j]);\n  }\n  const width = columns;\n  const height = rows;\n  divide(grid, 0, 0, width, height, chooseOrientation(width, height));\n\n  return { addedWalls, removedWalls, animAddedWalls: true };\n};\n\nconst divide = (grid, x, y, width, height, orientation) => {\n  if (height < 2 && width < 2) return;\n  const horizontal = orientation === HORIZONTAL;\n  let wx = x + (horizontal ? randEven(height - 2) : 0);\n  let wy = y + (horizontal ? 0 : randEven(width - 2));\n  const px = wx + (horizontal ? 0 : randOdd(height));\n  const py = wy + (horizontal ? randOdd(width) : 0);\n  const dx = horizontal ? 0 : 1;\n  const dy = horizontal ? 1 : 0;\n  do {\n    if (wx !== px || wy !== py) {\n      grid[wx][wy].isWall = true;\n      addedWalls.push(grid[wx][wy]);\n    }\n    wx += dx;\n    wy += dy;\n  } while (grid[wx][wy].isWall !== true);\n  let nx = x;\n  let ny = y;\n  let w = horizontal ? width : wy - y;\n  let h = horizontal ? wx - x : height;\n  divide(grid, nx, ny, w, h, chooseOrientation(w, h));\n  ny = horizontal ? y : wy;\n  nx = horizontal ? wx : x;\n  w = horizontal ? width : y + width - wy - 1;\n  h = horizontal ? x + height - wx - 1 : height;\n  divide(grid, nx, ny, w, h, chooseOrientation(w, h));\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) return HORIZONTAL;\n  else if (width > height) return VERTICAL;\n  return Math.random() >= 0.5 ? HORIZONTAL : VERTICAL;\n};\n\nconst randEven = i => {\n  return Math.floor(randomNumber(i, 2) / 2) * 2;\n};\nconst randOdd = i => {\n  return Math.floor(Math.random() * (i / 2)) * 2 + 1;\n};\n\nconst randomNumber = (max, min) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport default recursiveDivision;\n"]},"metadata":{},"sourceType":"module"}