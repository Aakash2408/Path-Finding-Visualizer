{"ast":null,"code":"const prim = (grid, rows, columns) => {\n  let addedWalls = [];\n  let removedWalls = [];\n  let open = {};\n  let frontier = {};\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < columns; j++) {\n      if (i % 2 === 0 || j % 2 === 0) {} else open[getKey(i, j)] = grid[i][j];\n\n      grid[i][j].isWall = true;\n      addedWalls.push(grid[i][j]);\n    }\n  }\n\n  const f = [[2, 0], [-2, 0], [0, 2], [0, -2]];\n  const n = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n  const start = open[randomKey(open)];\n  grid[start.row][start.col].isWall = false;\n  removedWalls.push(grid[start.row][start.col]);\n  f.forEach(i => {\n    const r = start.row + i[0];\n    const c = start.col + i[1];\n    if (grid[r] && grid[r][c] && grid[r][c].isWall && r !== 0 && c !== 0 && r !== rows - 1 && c !== columns - 1) frontier[getKey(r, c)] = grid[r][c];\n  });\n\n  while (Object.keys(frontier).length) {\n    const randFKey = randomKey(frontier);\n    const {\n      row,\n      col\n    } = frontier[randFKey];\n    let neighbours = {};\n    f.every((i, index) => {\n      const r = row + i[0];\n      const c = col + i[1];\n      const wr = row + n[index][0];\n      const wc = col + n[index][1];\n\n      if (grid[r] && grid[r][c] && !grid[r][c].isWall) {\n        neighbours[getKey(wr, wc)] = grid[wr][wc]; //return false for skew towards start\n        //return false;\n      }\n\n      return true;\n    });\n    const randNeighbour = neighbours[randomKey(neighbours)];\n    grid[randNeighbour.row][randNeighbour.col].isWall = false;\n    grid[frontier[randFKey].row][frontier[randFKey].col].isWall = false;\n    removedWalls.push(grid[randNeighbour.row][randNeighbour.col]);\n    removedWalls.push(grid[frontier[randFKey].row][frontier[randFKey].col]);\n    f.forEach(i => {\n      const r = frontier[randFKey].row + i[0];\n      const c = frontier[randFKey].col + i[1];\n      if (grid[r] && grid[r][c] && grid[r][c].isWall && r !== 0 && c !== 0 && r !== rows - 1 && c !== columns - 1) frontier[getKey(r, c)] = grid[r][c];\n    });\n    delete frontier[randFKey];\n  }\n\n  console.log(addedWalls.length);\n  return {\n    addedWalls,\n    removedWalls,\n    animAddedWalls: false\n  };\n};\n\nconst randomKey = obj => {\n  var keys = Object.keys(obj);\n  return keys[keys.length * Math.random() << 0];\n};\n\nconst getKey = (i, j) => {\n  return i.toString() + \"-\" + j.toString();\n};\n\nexport default prim;","map":{"version":3,"sources":["/media/aakash/2e3010a9-adce-4550-9e23-9a9e2129f7b4/aakash/Path-Finding-Visualizer/src/mazeGen/Prim.js"],"names":["prim","grid","rows","columns","addedWalls","removedWalls","open","frontier","i","j","getKey","isWall","push","f","n","start","randomKey","row","col","forEach","r","c","Object","keys","length","randFKey","neighbours","every","index","wr","wc","randNeighbour","console","log","animAddedWalls","obj","Math","random","toString"],"mappings":"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","sourcesContent":["const prim = (grid, rows, columns) => {\n  let addedWalls = [];\n  let removedWalls = [];\n  let open = {};\n  let frontier = {};\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < columns; j++) {\n      if (i % 2 === 0 || j % 2 === 0) {\n      } else open[getKey(i, j)] = grid[i][j];\n      grid[i][j].isWall = true;\n      addedWalls.push(grid[i][j]);\n    }\n  }\n  const f = [\n    [2, 0],\n    [-2, 0],\n    [0, 2],\n    [0, -2]\n  ];\n  const n = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1]\n  ];\n  const start = open[randomKey(open)];\n  grid[start.row][start.col].isWall = false;\n  removedWalls.push(grid[start.row][start.col]);\n  f.forEach(i => {\n    const r = start.row + i[0];\n    const c = start.col + i[1];\n    if (\n      grid[r] &&\n      grid[r][c] &&\n      grid[r][c].isWall &&\n      r !== 0 &&\n      c !== 0 &&\n      r !== rows - 1 &&\n      c !== columns - 1\n    )\n      frontier[getKey(r, c)] = grid[r][c];\n  });\n\n  while (Object.keys(frontier).length) {\n    const randFKey = randomKey(frontier);\n    const { row, col } = frontier[randFKey];\n    let neighbours = {};\n    f.every((i, index) => {\n      const r = row + i[0];\n      const c = col + i[1];\n      const wr = row + n[index][0];\n      const wc = col + n[index][1];\n      if (grid[r] && grid[r][c] && !grid[r][c].isWall) {\n        neighbours[getKey(wr, wc)] = grid[wr][wc];\n        //return false for skew towards start\n        //return false;\n      }\n      return true;\n    });\n    const randNeighbour = neighbours[randomKey(neighbours)];\n    grid[randNeighbour.row][randNeighbour.col].isWall = false;\n    grid[frontier[randFKey].row][frontier[randFKey].col].isWall = false;\n    removedWalls.push(grid[randNeighbour.row][randNeighbour.col]);\n    removedWalls.push(grid[frontier[randFKey].row][frontier[randFKey].col]);\n    f.forEach(i => {\n      const r = frontier[randFKey].row + i[0];\n      const c = frontier[randFKey].col + i[1];\n      if (\n        grid[r] &&\n        grid[r][c] &&\n        grid[r][c].isWall &&\n        r !== 0 &&\n        c !== 0 &&\n        r !== rows - 1 &&\n        c !== columns - 1\n      )\n        frontier[getKey(r, c)] = grid[r][c];\n    });\n    delete frontier[randFKey];\n  }\n  console.log(addedWalls.length);\n  return { addedWalls, removedWalls, animAddedWalls: false };\n};\n\nconst randomKey = obj => {\n  var keys = Object.keys(obj);\n  return keys[(keys.length * Math.random()) << 0];\n};\n\nconst getKey = (i, j) => {\n  return i.toString() + \"-\" + j.toString();\n};\n\nexport default prim;\n"]},"metadata":{},"sourceType":"module"}